<!DOCTYPE html>
<meta charset="utf-8">
<style>

#black {
  fill: black
}
#red {
  fill: red
}

.link {
  fill: none;
  stroke-width: 1.5px;
}
.link.plain.gray {
  stroke: #666;
}
/* This will probably never be used in practice. */
.link.plain.red {
  stroke: red;
}
.link.dashed {
  stroke-dasharray: 0,2 1;
}
.link.dashed.gray {
  stroke: #666;
}
.link.dashed.red {
  stroke: red;
}

.halo {
  stroke: #ccc;
  stroke-width: 4px;
  fill: none
}

.contributor {
  stroke: #333;
  stroke-width: 1.5px;
}
.contributor.gray {
  fill: #bbb;
}

text {
  font: 10px sans-serif;
  pointer-events: none;
  text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, -1px 0 0 #fff;
}

</style>
<head>
  <!-- TODO: What Content-Type should we set here? -->
  <link rel="shortcut icon" type="image/jpg" href="images/marionette.jpg" />
  <title>See the Strings</title>
</head>

<body>

<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="url-bundle.js"></script>
<script src="underscore-bundle.js"></script>
<script src="db-shim.js"></script>

<script>

var linkStyleMapping = {
  "D": {
    "true": "plain red",
    "false": "plain gray",
  },
  "I": {
    "true": "dashed red",
    "false": "dashed gray",
  },
};

var isagainstToMarkerColor = {
  "true": "red",
  "false": "black"
};

var queryParams = Url.parse(window.location.search, true).query;

function getLabelForLink(link) {
  // TODO: Consider displaying a refund by reversing the direction of the arrow, rather than by
  // showing a negative amount.
  //
  // Chrome and Firefox for Android don't render dollar signs generated by Number.toLocaleString()
  // correctly, so rather than pass in options { style: 'currency', currency: 'USD' }, we manually
  // add the dollar sign (and a minus sign if applicable).
  var absAmount = Math.abs(link.amount);
  var formattedAmount = (link.amount >= 0 ? "$" : "-$")
      + Number(absAmount).toLocaleString('en-US');
  return formattedAmount + (link.isRefund ? " (refund)" : "");
}

// TODO: It seems like this file shouldn't need to know about candidates or PACs.
//
// Can we pull this logic up into the form?
function getAggregateTypeForSeedType(seedType) {
  if (seedType == "Candidate" || seedType == "Race") {
    return "source";
  } else if (seedType == "PAC") {
    return "target";
  } else {
    console.log("Error: unknown seedType " + seedType);
    return null;
  }
}
function getAdjectiveForParty(party) {
  switch (party) {
  case "R": return "Republican";
  case "D": return "Democratic";
  case "L": return "Libertarian";
  case "3": return "Independent";
  case "U":
    // Don't return "Unknown" for unknown candidates since it isn't informative.
  default:
    return null;
  }
}
function setDisplayPropertiesForCandidateNode(node, link) {
  if (node.name == null) {
    if (link.targetname != null) {
      node.name = link.targetname;
    } else if (link.subLinks != null) {
      node.name = link.count + " ";
      if (link.party != null) {
        var adjective = getAdjectiveForParty(link.party);
        if (adjective != null) {
          node.name += adjective + " ";
        }
      }
      node.name += "candidates. Double click...";
    }
  }
  if (node.party == null || node.party == "U") {
    if (link.party != null) {
      node.party = link.party;
      console.log("Getting party " + node.party + " from link");
    } else {
      console.log("Party unknown");
      node.party = "U";  // unknown party
    }
  }
}
function setDisplayPropertiesForContributorNode(node, link) {
  if (node.name == null) {
    if (link.sourcename != null) {
      node.name = link.sourcename;
    } else if (link.subLinks != null) {
      // TODO: Should we only be accessing queryParams from high level methods like handleResponse
      // and buildGraph?
      var groupContributionsBy = queryParams["groupContributionsBy"];
      node.name = link.count + " ";
      if (groupContributionsBy == "Sector") {
        node.name += "sectors";
      } else if (groupContributionsBy == "Industry") {
        node.name += "industries";
      } else {
        node.name += "contributors"
      }
      node.name += ". Double click...";
    }
  }
}
function setDisplayPropertiesForNode(node, link) {
  if (node.id == link.sourceid) {
    setDisplayPropertiesForContributorNode(node, link);
  } else if (node.id == link.targetid) {
    setDisplayPropertiesForCandidateNode(node, link);
  } else {
    console.log("Error: node and link passed in are not related to each other");
  }
}

d3.json("/contributions" + window.location.search, handleResponse);

function handleResponse(err, rows) {
  // TODO: Check for errors.

  var seedType = queryParams["seedType"];
  console.log("Got seedType: " + seedType);

  var aggregateType = getAggregateTypeForSeedType(seedType);
  var links = processRows(rows, aggregateType);

  buildGraph(links);
}

var linkExistenceMap = {};
function getLinkNodesKey(link) {
  return link.sourceid + ", " + link.targetid;
}
function getLinkTypeKey(link) {
  return link.directorindirect + ", " + link.isagainst;
}
function addLinkToExistenceMap(link) {
  var nodesKey = getLinkNodesKey(link);
  var linkTypeMap = linkExistenceMap[nodesKey];
  if (linkTypeMap == null) {
    linkTypeMap = linkExistenceMap[nodesKey] = {};
  }
  var typeKey = getLinkTypeKey(link);
  linkTypeMap[typeKey] = link;
}
function removeLinkFromExistenceMap(link) {
  var nodesKey = getLinkNodesKey(link);
  var linkTypeMap = linkExistenceMap[nodesKey];
  if (linkTypeMap == null) {
    return;
  }
  var typeKey = getLinkTypeKey(link);
  linkTypeMap[typeKey] = null;
}

// TODO: Define dedicated methods to manage node and link addition and removal, to ensure that all
// relevant array and map data structures are kept in sync with one another.
function buildGraph(links) {
  var nodes = {};
  // Compute the distinct nodes from the links.
  links.forEach(
      function(link) {
        addLinkToExistenceMap(link);
        link.source = nodes[link.sourceid] ||
            (nodes[link.sourceid] = {
              name: link.sourcename,
              id: link.sourceid,
            });
        link.target = nodes[link.targetid] ||
            (nodes[link.targetid] = {
              name: link.targetname,
              id: link.targetid,
            });
        // Set the display properties for both nodes based on the properties of the link.
        setDisplayPropertiesForNode(link.source, link);
        setDisplayPropertiesForNode(link.target, link);
        if (link.subLinks != null) {
          // Add a reference to the aggregate link to the aggregate node so that we can find the
          // sub links when the user wants to expand it.
          link[link.childType].aggregateLink = link;
        }
      });
  var width = 1600,
      height = 1000;

  var svg = d3.select("body").append("svg")
      .attr("width", width)
      .attr("height", height);

  svg.append("g").selectAll("image")
      .data([0])
    .enter().append("image")
      .attr("x", 0)
      .attr("y", 0)
      .attr("width", 450)
      .attr("height", 300)
      .attr("xlink:href","images/legend.svg")

  var force = d3.layout.force()
      .nodes(d3.values(nodes))
      .links(links)
      .size([width, height])
      .linkDistance(200)
      .charge(-300)
      .friction(.75)
      .on("tick", tick);

  // Per-color markers, as they don't inherit styles.
  svg.append("defs").selectAll("marker")
      .data(["black", "red"])
    .enter().append("marker")
      .attr("id", function(d) { return d; })
      .attr("viewBox", "0 -5 10 10")
      .attr("refX", 9)
      .attr("refY", 0)
      .attr("markerWidth", 5)
      .attr("markerHeight", 5)
      .attr("orient", "auto")
    .append("path")
      .attr("d", "M0,-5L10,0L0,5");

  start();

  function tick() {
    path.attr("d", linkLine);
    halo.attr("transform", transformNodes);
    singleContributor.attr("transform", transformNodes);
    aggregateContributor.attr("transform", transformNodes);
    singleCandidate.attr("transform", transformNodes);
    aggregateCandidate.attr("transform", transformNodes);
    nodeText.attr("transform", transformNodes);
    linkText.attr("transform", transformLinkText);
  }

  function getLinkArcRadiusMultiplier(link) {
    // TODO: Figure out what mathematical relationship between consecutive multipliers yields
    // equidistant arcs.
    var multipliers = [ 1.0, 0.6, 0.51 ];
    var directInFavorTypeKey = "D, false";
    var indirectInFavorTypeKey = "I, false";
    var indirectAgainstTypeKey = "I, true";

    var nodesKey = getLinkNodesKey(link);
    var linkTypeMap = linkExistenceMap[nodesKey];
    if (linkTypeMap == null) {
      console.log("Warning: link missing from link existence map.")
      return multipliers[0];
    }
    var typeKey = getLinkTypeKey(link);
    switch (typeKey) {
    case directInFavorTypeKey:
      return multipliers[0];
    case indirectInFavorTypeKey:
      return linkTypeMap[directInFavorTypeKey] == null ?
          multipliers[0]
        : multipliers[1];
    case indirectAgainstTypeKey:
      var index = 0;
      index += (linkTypeMap[directInFavorTypeKey] != null);
      index += (linkTypeMap[indirectInFavorTypeKey] != null);
      return multipliers[index];
    }
  }

  function linkLine(d) {
    var adjLength = 8;
    var isClockwise = 1;

    var multiplier = getLinkArcRadiusMultiplier(d);

    var deltaX = d.target.x - d.source.x,
        deltaY = d.target.y - d.source.y;
    var slope = deltaY / deltaX;
    var adjX = isNaN(slope) ? 0 : Math.sqrt(Math.pow(adjLength, 2) / (Math.pow(slope, 2) + 1));
    var adjY = isNaN(slope) ? adjLength : Math.abs(slope * adjX);
    var endX = d.target.x - Math.sign(deltaX) * adjX;
    var endY = d.target.y - Math.sign(deltaY) * adjY;
    var radius = Math.sqrt(Math.pow(endX - d.source.x, 2) + Math.pow(endY - d.source.y, 2));

    return "M" + d.source.x + "," + d.source.y
        + "A" + radius * multiplier + "," + radius * multiplier
        + " 0 0," + isClockwise + " " + endX + "," + endY;
  }

  function transformNodes(d) {
    return "translate(" + d.x + "," + d.y + ")";
  }

  function transformLinkText(d) {
    var isClockwise = true;

    var multiplier = getLinkArcRadiusMultiplier(d);

    var deltaX = d.target.x - d.source.x,
        deltaY = d.target.y - d.source.y;
    var length = Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
    var skewLength = multiplier * length
        - length * Math.sqrt(4 * Math.pow(multiplier, 2) - 1) / 2;
    var textDist = Math.sqrt(Math.pow(skewLength, 2) + Math.pow(length / 2, 2));
    var adjAngle = Math.atan(2 * skewLength / length);
    var textAngle = Math.atan2(deltaY, deltaX) + (isClockwise ? -1 : 1) * adjAngle;
    var textX = d.source.x + Math.cos(textAngle) * textDist;
    var textY = d.source.y + Math.sin(textAngle) * textDist;
    return "translate(" + textX + "," + textY + ")";
  }

  // action to take on mouse double click
  function dblclick() {
    var nodeId = d3.select(this).attr("nodeId");
    var clickedNode = nodes[nodeId];
    var n = force.nodes().indexOf(clickedNode);
    if (clickedNode == null || n == -1) {
      console.log("Clicked node can't be found!");
      return;
    }
    if (!clickedNode.aggregateLink) {
      console.log("Clicked node is not an aggregate node")
      return;
    }
    var aggregateLink = clickedNode.aggregateLink;
    console.log("Removing existing link");
    removeLinkFromExistenceMap(aggregateLink);
    force.links().splice(force.links().indexOf(clickedNode.aggregateLink), 1);

    console.log("Removing existing " + childNameType + " node");
    force.nodes().splice(n, 1);

    var subLinks = aggregateLink.subLinks;
    var childType = aggregateLink.childType,
        childIdType = aggregateLink.childIdType,
        childNameType = aggregateLink.childNameType,
        relativeType = aggregateLink.relativeType,
        relativeIdType = aggregateLink.relativeIdType,
        relativeNameType = aggregateLink.relativeNameType;

    console.log("Clicked node has id " + clickedNode.id + " and name " + clickedNode.name);
    console.log("Link for clicked node has " + subLinks.length + " sub links");
    for (i = 0; i < subLinks.length; ++i) {
      var link = subLinks[i];
      console.log("Sub link " + i + " has name " + link[childNameType] + " and amount "
          + link.amount);
      var nodeChild = nodes[link[childIdType]];
      if (nodeChild == null || nodeChild.name != link[childNameType]) {
        nodeChild = nodes[link[childIdType]] = {
          name: link[childNameType],  // This will be null if the child is another aggregate.
          id: link[childIdType]
        };
        force.nodes().push(nodeChild);
        // Set the display properties for the new node based on the properties of the link.
        setDisplayPropertiesForNode(nodeChild, link);
        if (link.subLinks != null) {
          // Add a reference to the aggregate link to the aggregate node so that we can find the
          // sub links when the user wants to expand it.
          nodeChild.aggregateLink = link;
        }
      }
      // The relative of the clicked node should already exist in the graph, because the aggregate
      // was already linking to it.
      var nodeRelative = nodes[link[relativeIdType]];
      link[childType] = nodeChild;
      link[relativeType] = nodeRelative;
      // TODO: Replacing the old link and binding by index may not be safe. The subsequent call to
      // data().enter() may not return the new version of the link, in which case, style and color
      // changes might not take effect.
      console.log("Appending a new link");
      force.links().push(link);
      addLinkToExistenceMap(link);
    }

    restart();
  }

  function start() {
    restart(true);  // init = true
  }

  function restart(init) {
    if (init) {
      svg.append("g").attr("class", "gHalos");
      svg.append("g").attr("class", "gPaths");
      svg.append("g").attr("class", "gTextLink");
      svg.append("g").attr("class", "gSingleContributors");
      svg.append("g").attr("class", "gAggregateContributors");
      svg.append("g").attr("class", "gSingleCandidates");
      svg.append("g").attr("class", "gAggregateCandidates");
      svg.append("g").attr("class", "gTextNode");
    }

    // Define a special key function with different behavior depending on whether UI elements are
    // being initialized or updated.
    //   - If they're being intialized, simulate the default, by index behavior.
    //   - If they're being updated, use a link or node specific key function.
    function getJoinFunc(keyFunc) {
      return init ? function(d, i) { return i; } : keyFunc;
    }

    function linkKeyFunc(d) { return d.id + "; " + d.amount; }
    function nodeKeyFunc(d) { return d.id + "; " + d.name; }

    function isAggregateNode(d) { return d.aggregateLink != null; }

    function getImageForNodeWithParty(d) {
      // TODO: Try to find a way to avoid having one .svg file per party.
      return "images/person-" + d.party + ".svg";
    }

    // Global variables representing UI element selections are defined below.

    halo = svg.select(".gHalos").selectAll(".halo")
        .data(force.nodes().filter(isAggregateNode), getJoinFunc(nodeKeyFunc));
    halo.exit().remove();
    halo.enter().append("circle")
        .attr("r", 12)
        .attr("class", "halo")
        .attr("nodeId", function (d) { return d.id; })
        .on("dblclick", dblclick)
        .call(force.drag);

    path = svg.select(".gPaths").selectAll("path")
        .data(force.links(), getJoinFunc(linkKeyFunc));
    path.exit().remove();
    path.enter().append("path")
        .attr("class",
            function(d) {
              return "link " + linkStyleMapping[d.directorindirect][d.isagainst];
            })
        .attr("marker-end",
            function(d) {
              return "url(#" + isagainstToMarkerColor[d.isagainst] + ")";
            });

    linkText = svg.select(".gTextLink").selectAll(".textLink")
        .data(force.links(), getJoinFunc(linkKeyFunc));
    linkText.exit().remove();
    linkText.enter().append("text")
        .attr("class", "textLink")
        .attr("x", "-8")
        .attr("y", ".31em")
        .text(function(d) { return getLabelForLink(d); });

    singleContributor = svg.select(".gSingleContributors").selectAll("circle")
        .data(force.nodes().filter(
            function(d) {
              return d.party == null && d.aggregateLink == null;
            }),
            getJoinFunc(nodeKeyFunc));
    singleContributor.exit().remove();
    singleContributor.enter().append("circle")
        .attr("r", 6)
        .attr("class", "contributor gray")
        .attr("nodeId", function (d) { return d.id; })
        .on("dblclick", dblclick)
        .call(force.drag);

    var centerCircleRadius = 4.5;
    var circleOffset = 10;
    var circleScalingFactor = 0.75;
    aggregateContributor = svg.select(".gAggregateContributors").selectAll("g")
        .data(force.nodes().filter(
            function(d) {
              return d.party == null && d.aggregateLink != null;
            }),
            getJoinFunc(nodeKeyFunc));
    aggregateContributor.exit().remove();
    var gAggregateContributors = aggregateContributor.enter().append("g")
        .attr("nodeId", function (d) { return d.id; })
        .on("dblclick", dblclick)
        .call(force.drag);
    gAggregateContributors.append("circle")
        .attr("cx", circleOffset)
        .attr("r", circleScalingFactor * centerCircleRadius)
        .attr("class", "contributor gray");
    gAggregateContributors.append("circle")
        .attr("cx", -1 * circleOffset)
        .attr("r", circleScalingFactor * centerCircleRadius)
        .attr("class", "contributor gray");
    gAggregateContributors.append("circle")
        .attr("r", centerCircleRadius)
        .attr("class", "contributor gray");

    singleCandidate = svg.select(".gSingleCandidates").selectAll("image")
        .data(force.nodes().filter(
            function(d) {
              return d.party != null && d.aggregateLink == null;
            }),
            getJoinFunc(nodeKeyFunc));
    singleCandidate.exit().remove();
    singleCandidate.enter().append("image")
        .attr("x", "-4")
        .attr("y", "-10")
        .attr("width", 8)
        .attr("height", 20)
        .attr("xlink:href", getImageForNodeWithParty)
        .attr("nodeId", function (d) { return d.id; })
        .on("dblclick", dblclick)
        .call(force.drag);

    // TODO: Figure out to add a light drop shadow around each person so that they can overlap
    // and create a better sense of perspective.
    var centerPersonWidth = 6;
    var centerPersonHeight = 16;
    var personOffset = 8;
    var personScalingFactor = 0.75;
    aggregateCandidate = svg.select(".gAggregateCandidates").selectAll("g")
        .data(force.nodes().filter(
            function(d) {
              return d.party != null && d.aggregateLink != null;
            }),
            getJoinFunc(nodeKeyFunc));
    aggregateCandidate.exit().remove();
    var gAggregateCandidates = aggregateCandidate.enter().append("g")
        .attr("nodeId", function (d) { return d.id; })
        .on("dblclick", dblclick)
        .call(force.drag);
    gAggregateCandidates.append("image")
        .attr("x", personScalingFactor * (centerPersonWidth / -2 + personOffset))
        .attr("y",  personScalingFactor * centerPersonHeight / -2)
        .attr("width", centerPersonWidth * personScalingFactor)
        .attr("height", centerPersonHeight * personScalingFactor)
        .attr("xlink:href", getImageForNodeWithParty);
    gAggregateCandidates.append("image")
        .attr("x", personScalingFactor * (centerPersonWidth / -2 - personOffset))
        .attr("y", personScalingFactor * centerPersonHeight / -2)
        .attr("width", centerPersonWidth * personScalingFactor)
        .attr("height", centerPersonHeight * personScalingFactor)
        .attr("xlink:href", getImageForNodeWithParty);
    gAggregateCandidates.append("image")
        .attr("x", centerPersonWidth / -2)
        .attr("y", centerPersonHeight / -2)
        .attr("width", centerPersonWidth)
        .attr("height", centerPersonHeight)
        .attr("xlink:href", getImageForNodeWithParty);

    nodeText = svg.select(".gTextNode").selectAll(".textNode")
        .data(force.nodes(), getJoinFunc(nodeKeyFunc));
    nodeText.exit().remove();
    nodeText.enter().append("text")
        .attr("class", "textNode")
        .attr("x", "8")
        .attr("y", ".31em")
        .text(function(d) { return d.name; });

    force.start();
  }
}

</script>
</body>

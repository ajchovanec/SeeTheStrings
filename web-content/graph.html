<!DOCTYPE html>
<meta charset="utf-8">
<style>

#black {
  fill: black
}
#red {
  fill: red
}

.link {
  fill: none;
  stroke-width: 1.5px;
}
.link.plain.gray {
  stroke: #666;
}
/* This will probably never be used in practice. */
.link.plain.red {
  stroke: red;
}
.link.dashed {
  stroke-dasharray: 0,2 1;
}
.link.dashed.gray {
  stroke: #666;
}
.link.dashed.red {
  stroke: red;
}

.halo {
  stroke: #ccc;
  stroke-width: 4px;
  fill: none
}
.circle {
  stroke: #333;
  stroke-width: 1.5px;
}
.circle.gray {
  fill: #bbb;
}
.circle.white {
  fill: white;
}
.circle.red {
  fill: red;
}
circle.blue {
  fill: blue;
}
.circle.gold {
  fill: yellow;  /* TODO: gold */
}
.circle.purple {
  fill: purple;
}

text {
  font: 10px sans-serif;
  pointer-events: none;
  text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, -1px 0 0 #fff;
}

</style>
<head>
  <!-- TODO: What Content-Type should we set here? -->
  <link rel="shortcut icon" type="image/jpg" href="marionette.jpg" />
  <title>"See the Strings"</title>
</head>
<body>

<!-- object data="legend.svg" type="image/svg+xml" width="400"></object> -->

<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

var isAgainstToMarkerColor = {
  "true": "red",
  "false": "black"
}

function getStyleForParty(party) {
  switch (party) {
  case "R": return "red";
  case "D": return "blue";
  case "L": return "gold";
  case "3": return "purple";
  default: return "white" 
  }
}

d3.json("/data" + window.location.search, doStuff);

function doStuff(err, links) {
  // TODO: Check for errors.

  var nodes = {};
  // Compute the distinct nodes from the links.
  links.forEach(
      function(link) {
        var reportedSource = nodes[link.sourceid] ||
            (nodes[link.sourceid] = {
              name: link.source,
              id: link.sourceid,
              // TODO: We may need this if we start supportig
              //party: link.party
            });
        // TODO: What if the aggregate link is a net refund?
        if (link.subLinks != null) {
          reportedSource.outgoingAggregateLink = link;
          console.log("Top level aggregate link has " + link.subLinks.length + " sublinks");
        }
        var reportedTarget = nodes[link.targetid] ||
            (nodes[link.targetid] = {
              name: link.target,
              id: link.targetid,
              party: link.party
            });
        link.source = link.isRefund ? reportedTarget : reportedSource;
        link.target = link.isRefund ? reportedSource : reportedTarget;
        link.isRefund = null;
      });

  var width = 1600,
      height = 1000;

  var svg = d3.select("body").append("svg")
      .attr("width", width)
      .attr("height", height);

  var images = svg.append("g").attr("class", "gImgs").selectAll("image").data([0]);
  images.enter().append("image")
      .attr("x", 0)
      .attr("y", 0)
      .attr("width", 450)
      .attr("height", 300)
      .attr("xlink:href","legend.svg")

  var force = d3.layout.force()
      .nodes(d3.values(nodes))
      .links(links)
      .size([width, height])
      .linkDistance(200)
      .charge(-300)
      .friction(.75)
      .on("tick", tick)
      .start();

  // Per-color markers, as they don't inherit styles.
  svg.append("defs").selectAll("marker")
      .data(["black", "red"])
    .enter().append("marker")
      .attr("id", function(d) { return d; })
      .attr("viewBox", "0 -5 10 10")
      .attr("refX", 15)
      .attr("refY", -1.5)
      .attr("markerWidth", 6)
      .attr("markerHeight", 6)
      .attr("orient", "auto")
    .append("path")
      .attr("d", "M0,-5L10,0L0,5");

  var path = svg.append("g").attr("class", "gPaths").selectAll("path")
      .data(force.links())
    .enter().append("path")
      .attr("class", function(d) { return "link " + d.style; })
      .attr("marker-end",
          function(d) {
            return "url(#" + isAgainstToMarkerColor[d.isAgainst] + ")";
          });

  var circle = svg.append("g").attr("class", "gCircles").selectAll("circle")
      .data(force.nodes())
    .enter().append("circle")
      .attr("r", 6)
      .attr("nodeId",
          function (d) {
            return d.id;
          })
      .attr("class",
          function (d) {
            return "circle " + (d.party != null ? getStyleForParty(d.party) : "gray");
          })
      .on("dblclick", dblclick)
      .call(force.drag);

  var halo = svg.append("g").attr("class", "gHalos").selectAll(".halo")
      .data(force.nodes().filter(function (d) { return d.outgoingAggregateLink != null; }))
    .enter().append("circle")
      .attr("r", 11)
      .attr("nodeId",
          function (d) {
            return d.id;
          })
      .attr("class", function (d) { return "halo"; })
      .on("dblclick", dblclick)
      .call(force.drag);

  var nodeText = svg.append("g").attr("class", "gTextNode").selectAll(".textNode")
      .data(force.nodes())
    .enter().append("text")
      .attr("class", "textNode")
      .attr("x", "8")
      .attr("y", ".31em")
      .text(function(d) { return d.name; });
 
  var linkText = svg.append("g").attr("class", "gTextLink").selectAll(".textLink")
      .data(force.links())
    .enter().append("text")
      .attr("class", "textLink")
      .attr("x", "-8")
      .attr("y", ".31em")
      .text(function(d) { return d.label; });

  // TODO: Consider going back to elliptical arc path segments to doubly-encode directionality.
  function tick() {
    path.attr("d", linkLine);
    circle.attr("transform", transformNodes);
    halo.attr("transform", transformNodes);
    nodeText.attr("transform", transformNodes);
    linkText.attr("transform", transformLinkText);
  }

  function linkLine(d) {
    var dx = d.target.x - d.source.x,
        dy = d.target.y - d.source.y;
    return "M" + d.source.x + "," + d.source.y + "L" + d.target.x + "," + d.target.y;
  }

  function transformNodes(d) {
    return "translate(" + d.x + "," + d.y + ")";
  }

  function transformLinkText(d) {
    return "translate(" + (d.source.x + d.target.x) / 2 + "," + (d.source.y + d.target.y) / 2 + ")";
  }

  // action to take on mouse double click
  function dblclick() {
    var nodeId = d3.select(this).attr("nodeId");
    var clickedNode = null;  // = force.nodes()[nodeId];  // nodes[nodeId]
    var forceNodes = force.nodes();
    var forceLinks = force.links();
    var n = 0;
    for (; n < forceNodes.length; ++n) {
      if (forceNodes[n]["id"] == nodeId) {
        clickedNode = forceNodes[n];
        break;
      }
    }
    if (clickedNode == null) {
      return;
    }
    var linkReplaced = false;
    var nodeReplaced = false;
    if (clickedNode["outgoingAggregateLink"]) {
      console.log("Link for clicked node has " + clickedNode.outgoingAggregateLink.subLinks.length
          + " sub links");
      var subLinks = clickedNode.outgoingAggregateLink.subLinks;
      for (i = 0; i < subLinks.length; ++i) {
        var link = subLinks[i];
        console.log("Sub link " + i + " has name " + link.source + " and amount " + link.amount);
        var reportedSource = nodes[link.sourceid];  // should get fully populated value from force?
        if (reportedSource == null || reportedSource.name != link.source) {
          reportedSource = nodes[link.sourceid] = {
            name: link.source,
            id: link.sourceid,
            // TODO: We may need this if we start color coding PACs by party affiliation.
            //party: link.party
          };
          if (reportedSource.id == clickedNode.id && !nodeReplaced) {
            console.log("Replacing clicked source node " + clickedNode.name + " with "
                + reportedSource.name);
            forceNodes[n] = reportedSource;
            nodeReplaced = true;
          } else {
            console.log("Adding new source node " + reportedSource.name);
            forceNodes.push(reportedSource);
          }
          // TODO: What if the aggregate link is a net refund?
          if (link.subLinks != null) {
            reportedSource.outgoingAggregateLink = link;
          }
        }
        var reportedTarget = nodes[link.targetid];  // should get fully populated value from force?
        if (reportedTarget == null) {
          reportedTarget = nodes[link.targetid] = {
            name: link.target,
            id: link.targetid,
            party: link.party
          };
          forceNodes.push(reportedTarget);
        }
        link.source = link.isRefund ? reportedTarget : reportedSource;
        link.target = link.isRefund ? reportedSource : reportedTarget;
        link.isRefund = null;
        // TODO: Replacing the old link and binding by index may not be safe. The subsequent call to
        // data().enter() may not return the new version of the link, in which case, style and color
        // changes might not take effect.
        var linkAdded = false;
        if (!linkReplaced) {
          for (j = 0; j < forceLinks.length; ++j) {
            if (forceLinks[j].id == link.id) {
              console.log("Replacing an existing link");
              forceLinks[j] = link;
              linkReplaced = true;
              linkAdded = true;
              break;
            }
          }
        }
        if (!linkAdded) {
          console.log("Appending a new link");
          forceLinks.push(link);
        }
      }
      if (!linkReplaced ) {
        for (j = 0; j < forceLinks.length; ++j) {
          if (forceLinks[j].id == link.id) {
            console.log("Removing existing link because it has no sub links");
            forceLinks.splice(j, 1);
          }
        }
      }
      if (!nodeReplaced) {
        console.log("Removing existing source node " + clickedNode.name
            + ", because it has no sub links");
        forceNodes.splice(n, 1);
      }

      path = svg.select(".gPaths").selectAll("path")
          .data(forceLinks, function(d) { return d.id + "; " + d.amount; });
      path.exit().remove();
      path.enter().append("path")
          .attr("class", function(d) { return "link " + d.style; })
          .attr("marker-end",
              function(d) {
                return "url(#" + isAgainstToMarkerColor[d.isAgaist] + ")";
              });

      circle = svg.select(".gCircles").selectAll("circle")
          .data(forceNodes, function(d) { return d.id + "; " + d.name; });
      circle.exit().remove();
      circle.enter().append("circle")
          .attr("r", 6)
          .attr("nodeId", function (d) { return d.id; })
          .attr("class",
              function (d) {
                return "circle " + (d.party != null ? getStyleForParty(d.party) : "gray");
              })
          .on("dblclick", dblclick)
          .call(force.drag);

      halo = svg.select(".gHalos").selectAll(".halo")
          .data(forceNodes.filter(function (d) { return d.outgoingAggregateLink != null; }),
              function(d) { return d.id + "; " + d.name; });
      halo.exit().remove();
      halo.enter().append("circle")
          .attr("r", 11)
          .attr("nodeId",
              function (d) {
                return d.id;
              })
          .attr("class", function (d) { return "halo"; })
          .on("dblclick", dblclick)
          .call(force.drag);

      nodeText = svg.select(".gTextNode").selectAll(".textNode")
          .data(forceNodes, function(d) { return d.id + "; " + d.name; });
      nodeText.exit().remove();
      nodeText.enter().append("text")
          .attr("class", "textNode")
          .attr("x", "8")
          .attr("y", ".31em")
          .text(function(d) { return d.name; });

      linkText = svg.select(".gTextLink").selectAll(".textLink")
          .data(forceLinks, function(d) { return d.id + "; " + d.amount; });
      linkText.exit().remove();
      linkText.enter().append("text")
          .attr("class", "textLink")
          .attr("x", "-8")
          .attr("y", ".31em")
          .text(function(d) { return d.label; });

      force.start();
    }
  }
}

</script>
</body>

<!DOCTYPE html>
<meta charset="utf-8">
<style>

#black {
  fill: black
}
#red {
  fill: red
}

.link {
  fill: none;
  stroke-width: 1.5px;
}
.link.plain.gray {
  stroke: #666;
}
/* This will probably never be used in practice. */
.link.plain.red {
  stroke: red;
}
.link.dashed {
  stroke-dasharray: 0,2 1;
}
.link.dashed.gray {
  stroke: #666;
}
.link.dashed.red {
  stroke: red;
}

.halo {
  stroke: #ccc;
  stroke-width: 4px;
  fill: none
}
.circle {
  stroke: #333;
  stroke-width: 1.5px;
}
.circle.gray {
  fill: #bbb;
}
.circle.white {
  fill: white;
}
.circle.red {
  fill: red;
}
.circle.blue {
  fill: blue;
}
.circle.gold {
  fill: yellow;  /* TODO: gold */
}
.circle.purple {
  fill: purple;
}

text {
  font: 10px sans-serif;
  pointer-events: none;
  text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, -1px 0 0 #fff;
}

</style>
<head>
  <!-- TODO: What Content-Type should we set here? -->
  <link rel="shortcut icon" type="image/jpg" href="marionette.jpg" />
  <title>"See the Strings"</title>
</head>

<body>

<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="url-bundle.js"></script>
<script src="underscore-bundle.js"></script>
<script src="db-shim.js"></script>

<script>

var linkStyleMapping = {
  "D": {
    "true": "plain red",
    "false": "plain gray",
  },
  "I": {
    "true": "dashed red",
    "false": "dashed gray",
  },
};

var isagainstToMarkerColor = {
  "true": "red",
  "false": "black"
};

function getStyleForParty(party) {
  switch (party) {
  case "R": return "red";
  case "D": return "blue";
  case "L": return "gold";
  case "3": return "purple";
  default: return "white" 
  }
}

function getLabelForLink(link) {
  // TODO: Consider displaying a refund by reversing the direction of the arrow, rather than by
  // showing a negative amount.
  var formattedAmount =
      Number(link.amount).toLocaleString('en-US', { style: 'currency', currency: 'USD' });
  return formattedAmount + (link.isRefund ? " (refund)" : "");
}

// TODO: It seems like this file shouldn't need to know about candidates or PACs.
//
// Can we pull this logic up into the form?
function getAggregateTypeForSeedType(seedType) {
  if (seedType == "Candidate") {
    return "source";
  } else if (seedType == "PAC") {
    return "target";
  } else {
    console.log("Error: unknown seedType " + seedType);
    return null;
  }
}
function getLabelForAggregateCandidateNode(link) {
  return link.count + " candidates. Double click..."
}
function getLabelForAggregatePacNode(link) {
  return link.count + " contributors. Double click..."
}
function getLabelForAggregateNode(link, aggregateType) {
  if (aggregateType == "source") {
    return getLabelForAggregatePacNode(link);
  } else if (aggregateType == "target") {
    return getLabelForAggregateCandidateNode(link);
  } else {
    console.log("Error: unknown aggregateType " + aggregateType);
  }
}

d3.json("/data" + window.location.search, handleResponse);

function handleResponse(err, rows) {
  // TODO: Check for errors.

  var queryParams = Url.parse(window.location.search, true).query;
  var seedType = queryParams["seedType"];
  console.log("Got seedType: " + seedType);

  var aggregateType = getAggregateTypeForSeedType(seedType);
  var links = processRows(rows, aggregateType);

  buildGraph(links);
}

function buildGraph(links) {
  var nodes = {};
  // Compute the distinct nodes from the links.
  links.forEach(
      function(link) {
        if (link.subLinks != null) {
          link[link.childType] = getLabelForAggregateNode(link, link.childType);
        }
        var reportedSource = nodes[link.sourceid] ||
            (nodes[link.sourceid] = {
              name: link.source,
              id: link.sourceid,
              // TODO: Do we need this? Possibly, if we want to show party affiliations for PACs.
              //party: link.party
            });
        var reportedTarget = nodes[link.targetid] ||
            (nodes[link.targetid] = {
              name: link.target,
              id: link.targetid,
              party: link.party
            });
        link.source = reportedSource;
        link.target = reportedTarget;
        if (link.subLinks != null) {
          link[link.childType].aggregateLink = link;
        }
      });
  var width = 1600,
      height = 1000;

  var svg = d3.select("body").append("svg")
      .attr("width", width)
      .attr("height", height);

  svg.append("g").selectAll("image")
      .data([0])
    .enter().append("image")
      .attr("x", 0)
      .attr("y", 0)
      .attr("width", 450)
      .attr("height", 300)
      .attr("xlink:href","legend.svg")

  var force = d3.layout.force()
      .nodes(d3.values(nodes))
      .links(links)
      .size([width, height])
      .linkDistance(200)
      .charge(-300)
      .friction(.75)
      .on("tick", tick);

  // Per-color markers, as they don't inherit styles.
  svg.append("defs").selectAll("marker")
      .data(["black", "red"])
    .enter().append("marker")
      .attr("id", function(d) { return d; })
      .attr("viewBox", "0 -5 10 10")
      .attr("refX", 15)
      .attr("refY", -1.5)
      .attr("markerWidth", 6)
      .attr("markerHeight", 6)
      .attr("orient", "auto")
    .append("path")
      .attr("d", "M0,-5L10,0L0,5");

  start();

  // TODO: Consider going back to elliptical arc path segments to doubly-encode directionality.
  function tick() {
    path.attr("d", linkLine);
    circle.attr("transform", transformNodes);
    halo.attr("transform", transformNodes);
    nodeText.attr("transform", transformNodes);
    linkText.attr("transform", transformLinkText);
  }

  function linkLine(d) {
    var dx = d.target.x - d.source.x,
        dy = d.target.y - d.source.y;
    return "M" + d.source.x + "," + d.source.y + "L" + d.target.x + "," + d.target.y;
  }

  function transformNodes(d) {
    return "translate(" + d.x + "," + d.y + ")";
  }

  function transformLinkText(d) {
    return "translate(" + (d.source.x + d.target.x) / 2 + "," + (d.source.y + d.target.y) / 2 + ")";
  }

  // action to take on mouse double click
  function dblclick() {
    var nodeId = d3.select(this).attr("nodeId");
    var clickedNode = nodes[nodeId];  // = force.nodes()[nodeId];  // nodes[nodeId]
    var n = force.nodes().indexOf(clickedNode);
    if (clickedNode == null || n == -1) {
      console.log("Clicked node can't be found!");
      // Leaving this commented out for now to see if this ever causes an error.
      //return;
    }
    var linkReplaced = false;
    var nodeReplaced = false;
    if (clickedNode.aggregateLink) {
      var aggregateLink = clickedNode.aggregateLink;
      var subLinks = aggregateLink.subLinks;
      var childType = aggregateLink.childType,
          childIdType = aggregateLink.childIdType,
          relativeType = aggregateLink.relativeType,
          relativeIdType = aggregateLink.relativeIdType;

      console.log("Clicked node has id " + clickedNode.id + " and name " + clickedNode.name)
      console.log("Link for clicked node has " + subLinks.length + " sub links");
      for (i = 0; i < subLinks.length; ++i) {
        var link = subLinks[i];
        console.log("Sub link " + i + " has name " + link[childType] + " and amount "
            + link.amount);
        // TODO: Should we get fully populated value from force.nodes()?
        var reportedChild = nodes[link[childIdType]];
        if (reportedChild == null || reportedChild.name != link[childType]) {
          reportedChild = nodes[link[childIdType]] = {
            name: link[childType],  // This will be null if the child is another aggregate.
            id: link[childIdType],
            // TODO: We may need this if we start color coding PACs by party affiliation.
            //party: link.party
          };
          if (reportedChild.id == clickedNode.id && !nodeReplaced) {
            console.log("Replacing clicked " + childType + " node " + clickedNode.name + " with "
                + reportedChild.name);
            force.nodes()[n] = reportedChild;
            nodeReplaced = true;
          } else {
            console.log("Adding new " + childType + " node " + reportedChild.name);
            force.nodes().push(reportedChild);
          }
          // TODO: This transitive logic for setting up the next, finer grained aggregate will
          // probably break in a graph where we have both aggregate source and child nodes.
          if (link.subLinks != null) {
            reportedChild.aggregateLink = link;
            reportedChild.name = getLabelForAggregateNode(link, childType);
          }
        }
        // TODO: Should we get fully populated value from force.nodes()?
        var reportedRelative = nodes[link[relativeIdType]];
        if (reportedRelative == null) {
          // TODO: This probably can't actually happen. The child node should be related to the same
          // node as the aggregate node is. And if the already displayed aggregate has a link to
          // that node, then it must be defined. This can probably be removed.
          reportedRelative = nodes[link[relativeIdType]] = {
            name: link[relativeType],
            id: link[relativeIdType],
            // TODO: Seeing as we're trying to make this code more generic, it's a little awkward
            // that we need to set this field here.
            party: link.party
          };
          force.nodes().push(reportedRelative);
        }
        link[childType] = reportedChild;
        link[relativeType] = reportedRelative;
        // TODO: Replacing the old link and binding by index may not be safe. The subsequent call to
        // data().enter() may not return the new version of the link, in which case, style and color
        // changes might not take effect.
        var linkAdded = false;
        if (!linkReplaced) {
          var j = _.findIndex(force.links(), function(l) { return l.id == link.id; });
          if (j != -1) {
            // TODO: We're assuming that because we found another link with the same id as the
            // current sub link, that must mean that it's the aggregate link from the clicked
            // node, and furthermore that the current sub link must be a smaller aggregate link
            // which was previously subsumed by the aforesaid larger aggregate link... This might
            // not be a valid assumption.
            force.links()[j] = link;
            linkReplaced = true;
            linkAdded = true;
          }
        }
        if (!linkAdded) {
          console.log("Appending a new link");
          force.links().push(link);
        }
      }
      if (!linkReplaced) {
        console.log("Removing existing link because it has no sub links");
        force.links().splice(force.links().indexOf(clickedNode.aggregateLink), 1);
      }
      if (!nodeReplaced) {
        console.log("Removing existing " + childType + " node " + clickedNode.name
            + ", because it has no sub links");
        console.log("Node actually being removed has name " + force.nodes()[n].name)
        force.nodes().splice(n, 1);
      }

      restart();
    }
  }

  function start() {
    restart(true);  // init = true
  }

  function restart(init) {
    if (init) {
      svg.append("g").attr("class", "gPaths");
      svg.append("g").attr("class", "gTextLink");
      svg.append("g").attr("class", "gCircles");
      svg.append("g").attr("class", "gHalos");
      svg.append("g").attr("class", "gTextNode");
    }

    // Define a special key function with different behavior depending on whether UI elements are
    // being initialized or updated.
    //   - If they're being intialized, simulate the default, by index behavior.
    //   - If they're being updated, use a link or node specific key function.
    function getJoinFunc(keyFunc) {
      return init ? function(d, i) { return i; } : keyFunc;
    }

    function linkKeyFunc(d) { return d.id + "; " + d.amount; }
    function nodeKeyFunc(d) { return d.id + "; " + d.name; }

    function isAggregateNode(d) { return d.aggregateLink != null; }

    // Global variables representing UI element selections are defined below.

    path = svg.select(".gPaths").selectAll("path")
        .data(force.links(), getJoinFunc(linkKeyFunc));
    path.exit().remove();
    path.enter().append("path")
        .attr("class",
            function(d) {
              return "link " + linkStyleMapping[d.directorindirect][d.isagainst];
            })
        .attr("marker-end",
            function(d) {
              return "url(#" + isagainstToMarkerColor[d.isagainst] + ")";
            });

    linkText = svg.select(".gTextLink").selectAll(".textLink")
        .data(force.links(), getJoinFunc(linkKeyFunc));
    linkText.exit().remove();
    linkText.enter().append("text")
        .attr("class", "textLink")
        .attr("x", "-8")
        .attr("y", ".31em")
        .text(function(d) { return getLabelForLink(d); });

    circle = svg.select(".gCircles").selectAll("circle")
        .data(force.nodes(), getJoinFunc(nodeKeyFunc));
    circle.exit().remove();
    circle.enter().append("circle")
        .attr("r", 6)
        .attr("nodeId", function (d) { return d.id; })
        .attr("class",
            function (d) {
              return "circle " + (d.party != null ? getStyleForParty(d.party) : "gray");
            })
        .on("dblclick", dblclick)
        .call(force.drag);

    halo = svg.select(".gHalos").selectAll(".halo")
        .data(force.nodes().filter(isAggregateNode), getJoinFunc(nodeKeyFunc));
    halo.exit().remove();
    halo.enter().append("circle")
        .attr("r", 11)
        .attr("nodeId", function (d) { return d.id; })
        .attr("class", "halo")
        .on("dblclick", dblclick)
        .call(force.drag);

    nodeText = svg.select(".gTextNode").selectAll(".textNode")
        .data(force.nodes(), getJoinFunc(nodeKeyFunc));
    nodeText.exit().remove();
    nodeText.enter().append("text")
        .attr("class", "textNode")
        .attr("x", "8")
        .attr("y", ".31em")
        .text(function(d) { return d.name; });

    force.start();
  }
}

</script>
</body>

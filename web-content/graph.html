<!DOCTYPE html>
<meta charset="utf-8">
<style>

#black {
  fill: black
}
#red {
  fill: red
}

.link {
  fill: none;
}
.link.plain.gray {
  stroke: #666;
}
/* This will probably never be used in practice. */
.link.plain.red {
  stroke: red;
}
.link.dashed {
  stroke-dasharray: 0,2 1;
}
.link.dashed.gray {
  stroke: #666;
}
.link.dashed.red {
  stroke: red;
}

.halo {
  stroke: #ccc;
  stroke-width: 4px;
  fill: none
}

text {
  font: 10px sans-serif;
  pointer-events: none;
  text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, -1px 0 0 #fff;
}

</style>
<head>
  <!-- TODO: What Content-Type should we set here? -->
  <link rel="shortcut icon" type="image/jpg" href="images/marionette.jpg" />
  <title>See the Strings</title>
</head>

<body>

<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="libs/graphlib-bundle.js"></script>
<script src="libs/underscore-bundle.js"></script>
<script src="libs/url-bundle.js"></script>
<script src="libs/db-shim.js"></script>

<script>

var linkStyleMapping = {
  "D": {
    "true": "plain red",
    "false": "plain gray",
  },
  "I": {
    "true": "dashed red",
    "false": "dashed gray",
  },
};

var isagainstToMarkerColor = {
  "true": "red",
  "false": "black"
};

var queryParams = Url.parse(window.location.search, true).query;

function getLabelForLink(link) {
  // TODO: Consider displaying a refund by reversing the direction of the arrow, rather than by
  // showing a negative amount.
  //
  // Chrome and Firefox for Android don't render dollar signs generated by Number.toLocaleString()
  // correctly, so rather than pass in options { style: 'currency', currency: 'USD' }, we manually
  // add the dollar sign (and a minus sign if applicable).
  var absAmount = Math.abs(link.amount);
  var formattedAmount = (link.amount >= 0 ? "$" : "-$")
      + Number(absAmount).toLocaleString('en-US');
  return formattedAmount + (link.isRefund ? " (refund)" : "");
}

function getAdjectiveForParty(party) {
  switch (party) {
    case "R": return "Republican";
    case "D": return "Democratic";
    case "L": return "Libertarian";
    case "I": return "Independent"
    case "3": return "other third party";
    case "U":
      // Don't return "Unknown" for unknown candidates since it isn't informative.
    default:
      return null;
  }
}

function setDisplayPropertiesForLink(link) {
  // A PAC node can be a source for a contribution to a candidate, or a target for a contribution
  // from an individual. To make certain that all links that a PAC node participates in *appear* to
  // have the same orientation, we actually need to *invert* the orientation (from clockwise to
  // counter clockwise) in the case of an individual to PAC link.
  if (link.sourcetype == "indiv" && link.targettype == "pac") {
    link.orientation = 0;  // counterclockwise
  } else {
    link.orientation = 1;  // clockwise
  }
}

function setDisplayPropertiesForPacNode(node, link) {
  if (node.name == null) {
    if (node.aggregate) {
      // TODO: Should we only be accessing queryParams from high level methods like handleResponse
      // and buildGraph?
      var groupContributionsBy = queryParams["groupContributionsBy"];
      node.name = Number(link.count).toLocaleString('en-US');
      console.log()
      if (groupContributionsBy == "Sector") {
        node.name += " sectors";
      } else if (groupContributionsBy == "Industry") {
        node.name += " industries";
      } else {
        node.name += " committees";
      }
      if (link.subLinks != null) {
        node.name += ". Double click...";
      }
    }
  }
}
function setDisplayPropertiesForCandidateNode(node, link) {
  if (node.name == null) {
    if (node.aggregate) {
      node.name = Number(link.count).toLocaleString('en-US');
      if (link.party != null) {
        var adjective = getAdjectiveForParty(link.party);
        if (adjective != null) {
          node.name += " " + adjective;
        }
      }
      node.name += " candidates";
      if (link.subLinks != null) {
        node.name += ". Double click...";
      }
    }
  }
  if (node.party == null || node.party == "U") {
    if (link.party != null) {
      node.party = link.party;
      console.log("Getting party " + node.party + " from link");
    } else {
      console.log("Party unknown");
      node.party = "U";  // unknown party
    }
  }
}
function setDisplayPropertiesForIndivNode(node, link) {
  if (node.name == null && node.aggregate) {
    node.name = Number(link.count).toLocaleString('en-US') + " individuals";
    if (link.subLinks != null) {
      node.name += ". Double click...";
    }
  }
}
function setDisplayPropertiesForNode(node, link) {
  if (node.nodetype == "pac") {
    setDisplayPropertiesForPacNode(node, link);
  } else if (node.nodetype == "candidate") {
    setDisplayPropertiesForCandidateNode(node, link);
  } else if (node.nodetype == "indiv") {
    setDisplayPropertiesForIndivNode(node, link);
  } else {
    console.log("Error: node and link passed in are not related to each other");
  }
}

d3.json("/contributions" + window.location.search, handleResponse);

function handleResponse(err, rows) {
  if (err != null) {
    console.log("Error while fetching contributions: " + err);
    // TODO: This code will never execute as long as server.js isn't configured to return a 400 or
    // 500 server error when something goes wrong. We need to make a corresponding change there too.
    //
    // TODO: Also display a visible error message to the user.
    return;
  }

  var candidates = queryParams["candidates"];
  var pacs = queryParams["pacs"];

  if (!(candidates instanceof Array)) {
    candidates = [ candidates ];
  }
  if (!(pacs instanceof Array)) {
    pacs = [ pacs ];
  }

  var seedIds = [];
  Array.prototype.push.apply(seedIds, pacs);
  Array.prototype.push.apply(seedIds, candidates);

  var links = processRows(rows, seedIds);

  showGraph(links);
}

// TODO: Turn this into an object prototype or something.
var graph = {
  _impl: new Graph.Graph({ directed: true, multigraph: true }),
  _nodes: [],
  _links: {},
  init:
      function(inputLinks) {
        var self = this;
        var nodesMap = [];
        this._links = inputLinks;
        // Compute the distinct nodes from the links.
        this._links.forEach(
            function(link) {
              link.source = nodesMap[link.sourceid] ||
                  (nodesMap[link.sourceid] = {
                    name: link.sourcename,
                    id: link.sourceid,
                    aggregateLinks: [],
                    // TODO: Once we have nodes that are both a source and a target at the same
                    // time, it may be necessary to mark a node as a seed if *any* link that has it
                    // as a source or a target has it marked as a seed.
                    seed: link.seedsource,
                    nodetype: link.sourcetype,
                    aggregate: link.sourceaggregate,
                    incomingAmount: 0,
                    outgoingAmount: 0
                  });
              link.target = nodesMap[link.targetid] ||
                  (nodesMap[link.targetid] = {
                    name: link.targetname,
                    id: link.targetid,
                    aggregateLinks: [],
                    // TODO: Once we have nodes that are both a source and a target at the same
                    // time, it may be necessary to mark a node as a seed if *any* link that has it
                    // as a source or a target has it marked as a seed.
                    seed: link.seedtarget,
                    nodetype: link.targettype,
                    aggregate: link.targetaggregate,
                    incomingAmount: 0,
                    outgoingAmount: 0
                  });
              link.source.outgoingAmount += link.amount;
              link.target.incomingAmount += link.amount;
              // Set the display properties for the link and its source and target nodes.
              //
              // TODO: Since a single node will usually participate in multiple links, we will
              // usually end up setting its display properties multiple times. Make certain that the
              // display properties that it ends up having in the end don't depend on the order in
              // which the links are processed.
              //
              // TODO: Move these display-related calls out of this method.
              setDisplayPropertiesForLink(link);
              setDisplayPropertiesForNode(link.source, link);
              setDisplayPropertiesForNode(link.target, link);
              if (link.subLinks != null) {
                // Add a reference to the aggregate link to the aggregate node so that we can find
                // the sub links when the user wants to expand it.
                link[link.childType].aggregateLinks.push(link);
                if (link[link.childType].aggregateLinks.length > 1) {
                  console.log("Error: node has more than 1 aggregate link! (Actual count is "
                      + link[link.childType].aggregateLinks.length + ")");
                }
              }
            });
        this._nodes = _.values(nodesMap);

        this._nodes.forEach(
            function(node) {
              self._impl.setNode(node.id, node);
            });
        this._links.forEach(
            function(link) {
              self._impl.setEdge(link.sourceid, link.targetid, link,  self.getLinkTypeKey(link));
            });
      },
  nodes:
      function() {
        return this._nodes;
      },
  links:
      function() {
        return this._links;
      },
  getNode:
      function(nodeId) {
        return this._impl.node(nodeId);
      },
  getLink:
      function(sourceId, targetId, typeKey) {
        return this._impl.edge(sourceId, targetId, typeKey);
      },
  addNode:
      function(node) {
        // TODO: Do some kind of validation on the node passed in.
        this._nodes.push(node);
        this._impl.setNode(node.id, node);
      },
  removeNode:
      // TODO: Modify this method to take in a node id instead of a node.
      function(node) {
        if (this._impl.nodeEdges(node.id).length > 0) {
          console.log("Error: attempting to delete node from graph before severing all its links");
          return;
        }
        var i = this.nodes().indexOf(node);
        if (i != -1) {
          this._impl.removeNode(node.id);
          this.nodes().splice(i, 1);
        }
      },
  addLink:
      function(link) {
        // TODO: Do some kind of validation on the node passed in.
        this._links.push(link);
        this._impl.setEdge(link.sourceid, link.targetid, link, this.getLinkTypeKey(link));
      },
  removeLink:
      // TODO: Consider modifying this method to take in a source id, target id, and link type key
      // instead of a link.
      function(link) {
        var i = graph.links().indexOf(link);
        if (i != -1) {
          this._impl.removeEdge(link.sourceid, link.targetid, this.getLinkTypeKey(link));
          this._links.splice(i, 1);
        }
      },
  // TODO: Try to find a way to get rid of this method.
  getLinkTypeKey:
      function(link) {
        return link.directorindirect + ", " + link.isagainst;
      },
}

// TODO: Define dedicated methods to manage node and link addition and removal, to ensure that all
// relevant array and map data structures are kept in sync with one another.
function showGraph(inputLinks) {
  graph.init(inputLinks);

  var width = 1600,
      height = 1200;

  var svg = d3.select("body").append("svg")
      .attr("width", width)
      .attr("height", height);

  svg.append("g").selectAll("image")
      .data([0])
    .enter().append("image")
      .attr("x", 0)
      .attr("y", 0)
      .attr("width", 450)
      .attr("height", 300)
      .attr("xlink:href","images/legend.svg")

  var force = d3.layout.force()
      .nodes(graph.nodes())
      .links(graph.links())
      .size([width, height])
      .linkDistance(300)
      .charge(-600)
      .friction(.75)
      .on("tick", tick);

  // Per-color markers, as they don't inherit styles.
  svg.append("defs").selectAll("marker")
      .data(["black", "red"])
    .enter().append("marker")
      .attr("id", function(d) { return d; })
      .attr("viewBox", "0 -5 10 10")
      .attr("refX", 9)
      .attr("refY", 0)
      .attr("markerWidth", 5)
      .attr("markerHeight", 5)
      .attr("orient", "auto")
    .append("path")
      .attr("d", "M0,-5L10,0L0,5");

  start();

  function tick() {
    path.attr("d", linkLine);
    halo.attr("transform", transformNodes);
    singlePac.attr("transform", transformNodes);
    aggregatePac.attr("transform", transformNodes);
    singleIndiv.attr("transform", transformNodes);
    aggregateIndiv.attr("transform", transformNodes);
    singleCandidate.attr("transform", transformNodes);
    aggregateCandidate.attr("transform", transformNodes);
    nodeText.attr("transform", transformNodeText);
    linkText.attr("transform", transformLinkText);
  }

  function getLinkArcRadiusMultiplier(link) {
    // 1.00000 yields an arc with height 1 - sqrt(3) / 2.
    // 0.60048 ~= 5 / 4 - 3 * sqrt(3) / 8 and yields an arc with height 2 * (1 - sqrt(3) / 2).
    // 0.51197 ~= 5 / 3 - 2 * sqrt(3) / 3 and yields an arc with height 3 * (1 - sqrt(3) / 2).
    var multipliers = [ 1, 0.60048, 0.51197 ];
    var directInFavorTypeKey = "D, false";
    var indirectInFavorTypeKey = "I, false";
    var indirectAgainstTypeKey = "I, true";

    var hasDirectInFavor =
        graph.getLink(link.sourceid, link.targetid, directInFavorTypeKey) != null;
    var hasIndirectInFavor =
        graph.getLink(link.sourceid, link.targetid, indirectInFavorTypeKey) != null;

    var typeKey = graph.getLinkTypeKey(link);
    switch (typeKey) {
      case directInFavorTypeKey:
        return multipliers[0];
      case indirectInFavorTypeKey:
        return hasDirectInFavor ?
            multipliers[1]
          : multipliers[0];
      case indirectAgainstTypeKey:
        var index = 0;
        index += hasDirectInFavor;
        index += hasIndirectInFavor;
        return multipliers[index];
    }
  }

  function isAggregateNode(node) {
    return node.aggregate;
  }
  function isExpandableNode(node) {
    return node.aggregateLinks.length > 0;
  }
  function getAmountMagnitudeForNode(node) {
    return Math.max(Math.abs(node.incomingAmount), Math.abs(node.outgoingAmount));
  }
  function getWidthForLink(link) {
    var amountMagnitude = Math.abs(link.amount);
    return Math.pow(amountMagnitude, 0.10);
  }
  function getScaleForNode(node) {
    var amountMagnitude = getAmountMagnitudeForNode(node);
    return 0.8 * Math.pow(amountMagnitude, 0.1);
  }
  function getScaleForText(amount) {
    var amountMagnitude = Math.abs(amount);
    return Math.pow(amountMagnitude, 0.03);
  }
  function getEffectiveNodeRadius(node) {
    // TODO: This logic is overly simplistic and will have to evolve. It assumes that PAC nodes will
    // always be sources, and it assumes that all non-PAC nodes will have the same pre-scaled size.
    var multiplier;
    if (isExpandableNode(node)) {
      multiplier = 12;
    } else if (node.nodetype == "pac") {
      multiplier = isAggregateNode(node) ? 5 : 10;
    } else {
      multiplier = 8;
    }
    return multiplier * getScaleForNode(node);
  }

  // This helper function is shared between the linkLine() and transformLinkText() methods.
  function getLinkOrientationMultiplier(orientation) {
    return orientation ? -1 : 1;
  }

  function linkLine(d) {
    var linkOrientation = d.orientation;
    var linkOrientationMultiplier = getLinkOrientationMultiplier(linkOrientation);

    var effectiveSourceRadius = getEffectiveNodeRadius(d.source);
    var effectiveTargetRadius = getEffectiveNodeRadius(d.target);

    var deltaX = d.target.x - d.source.x,
        deltaY = d.target.y - d.source.y;
    var distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    if (distance < effectiveTargetRadius) {
      return null;  // no path to draw
    }

    var midX = (d.source.x + d.target.x) / 2;
    var midY = (d.source.y + d.target.y) / 2;

    var multiplier = getLinkArcRadiusMultiplier(d);
    var arcRadius = multiplier * distance;
    var arcCenterX = midX
        + Math.sqrt(arcRadius * arcRadius - distance * distance / 4)
            * linkOrientationMultiplier * deltaY / distance;
    var arcCenterY = midY
        - Math.sqrt(arcRadius * arcRadius - distance * distance / 4)
            * linkOrientationMultiplier * deltaX / distance;

    var arcSourceIntersect = getCircleIntersection(arcCenterX, arcCenterY, arcRadius,
        d.source.x, d.source.y, effectiveSourceRadius, -linkOrientationMultiplier);
    var arcTargetIntersect = getCircleIntersection(arcCenterX, arcCenterY, arcRadius,
        d.target.x, d.target.y, effectiveTargetRadius, linkOrientationMultiplier);
    if (!arcSourceIntersect || !arcTargetIntersect) {
      return null;  // no path to draw
    }
    var sourceX = arcSourceIntersect[0],
        sourceY = arcSourceIntersect[1];
    var targetX = arcTargetIntersect[0],
        targetY = arcTargetIntersect[1];
    return "M" + sourceX + "," + sourceY + "A" + arcRadius + "," + arcRadius
        + " 0 0," + linkOrientation + " " + targetX + "," + targetY;
  }

  function getCircleIntersection(x0, y0, radius0, x1, y1, radius1, which) {
    var a, dx, dy, d, h, rx, ry;
    var x2, y2;

    dx = x1 - x0;
    dy = y1 - y0;

    d = Math.sqrt((dy * dy) + (dx * dx));

    if (d > (radius0 + radius1)) {
      return false;
    }
    if (d < Math.abs(radius0 - radius1)) {
      return false;
    }

    // Point 2 is the point where the line through the circle intersection points crosses the line
    // between the circle centers.

    // Determine the distance from point 0 to point 2.
    a = ((radius0 * radius0) - (radius1 * radius1) + (d * d)) / (2.0 * d) ;

    // Determine the coordinates of point 2.
    x2 = x0 + (dx * a / d);
    y2 = y0 + (dy * a / d);

    // Determine the distance from point 2 to either of the intersection points.
    h = Math.sqrt((radius0 * radius0) - (a*a));

    // Now determine the offsets of the intersection points from point 2.
    rx = -dy * (h / d);
    ry = dx * (h / d);

    // Determine the absolute intersection points.
    var xi = x2 + which * rx;
    var yi = y2 + which * ry;
    return [xi, yi];
  }

  function transformLinkText(d) {
    var linkOrientation = d.orientation;
    var linkOrientationMultiplier = getLinkOrientationMultiplier(linkOrientation);

    var deltaX = d.target.x - d.source.x,
        deltaY = d.target.y - d.source.y;
    var distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    var effectiveTargetRadius = getEffectiveNodeRadius(d.target)
    if (distance < effectiveTargetRadius) {
      return null;  // no path to draw
    }

    var multiplier = getLinkArcRadiusMultiplier(d);
    var arcRadius = multiplier * distance;
    var arcHeight = (multiplier - Math.sqrt(4 * multiplier * multiplier - 1) / 2) * distance;
    var textDistance = Math.sqrt(arcHeight * arcHeight + Math.pow(distance / 2, 2));
    var adjAngle = Math.atan(2 * arcHeight / distance);
    var textAngle = Math.atan2(deltaY, deltaX) + linkOrientationMultiplier * adjAngle;
    var textX = d.source.x + Math.cos(textAngle) * textDistance;
    var textY = d.source.y + Math.sin(textAngle) * textDistance;
    var scale = getScaleForText(d.amount);
    return "translate(" + textX + "," + textY + ") scale(" + scale + ")";
  }

  function transformNodeText(d) {
    var effectiveAmount = getAmountMagnitudeForNode(d);
    var scale = getScaleForText(effectiveAmount);
    return "translate(" + d.x + "," + d.y + ") scale(" + scale + ")";
  }

  function transformNodes(d) {
    var scale = getScaleForNode(d);
    return "translate(" + d.x + "," + d.y + ") scale(" + scale + ")";
  }

  // action to take on mouse double click
  function dblclick() {
    var nodeId = d3.select(this).attr("nodeId");
    var clickedNode = graph.getNode(nodeId);
    if (clickedNode == null || graph.getNode(clickedNode.id) == null) {
      console.log("Clicked node can't be found!");
      return;
    }
    if (clickedNode.aggregateLinks.length == 0) {
      console.log("Clicked node with id " + nodeId + " is not an aggregate node");
      return;
    }

    // We have to remove all the aggregate links from the graph before we can delete the aggregate
    // node, but we also have to delete the aggregate node before we can expand the aggregate links
    // (since there) may be a new child aggregate node with the same id as the old one.
    //
    // TODO: This is really awkward. Try to find a better way.

    clickedNode.aggregateLinks.forEach(
        function(aggregateLink) {
          console.log("Removing existing aggregate link to clicked node with id " + nodeId);
          graph.removeLink(aggregateLink);
        });

    console.log("Removing clicked node with id " + nodeId + " and name " + clickedNode.name);
    graph.removeNode(clickedNode);

    clickedNode.aggregateLinks.forEach(expandAggregateLink);

    restart();
  }

  function expandAggregateLink(aggregateLink) {
    var subLinks = aggregateLink.subLinks;
    var childType = aggregateLink.childType,
        childIdType = aggregateLink.childIdType,
        childNameType = aggregateLink.childNameType,
        relativeType = aggregateLink.relativeType,
        relativeIdType = aggregateLink.relativeIdType,
        relativeNameType = aggregateLink.relativeNameType;

    console.log("Aggregate link for clicked node has " + subLinks.length + " sub links");
    for (i = 0; i < subLinks.length; ++i) {
      var link = subLinks[i];
      console.log("Sub link " + i + " has name " + link[childNameType] + " and amount "
          + link.amount);
      var nodeChild = graph.getNode(link[childIdType]);
      if (nodeChild == null || nodeChild.name != link[childNameType]) {
        nodeChild = {
          name: link[childNameType],  // This will be null if the child is another aggregate.
          id: link[childIdType],
          aggregateLinks: [],
          // TODO: Once we have nodes that are both a source and a target at the same
          // time, it may be necessary to mark a node as a seed if *any* link that has it
          // as a source or a target has it marked as a seed.
          seed: link["seed" + childType],  // FIXME
          nodetype: link[childType + "type"],  // FIXME
          aggregate: link[childType + "aggregate"],  // FIXME
          incomingAmount: 0,
          outgoingAmount: 0
        };
        if (childType == "source") {  // FIXME
          nodeChild.outgoingAmount += link.amount;
        } else {
          nodeChild.incomingAmount += link.amount;
        }
        graph.addNode(nodeChild);
        // Set the display properties for the new node.
        setDisplayPropertiesForNode(nodeChild, link);
        if (link.subLinks != null) {
          // Add a reference to the aggregate link to the aggregate node so that we can find the
          // sub links when the user wants to expand it.
          nodeChild.aggregateLinks.push(link);
          if (nodeChild.aggregateLinks.length > 1) {
            console.log("Error: former child node has more than 1 aggregate link! (Actual count is "
                + nodeChild.aggregateLinks.length + ")");
          }
        }
      }
      // The relative of the clicked node should already exist in the graph, because the aggregate
      // was already linking to it.
      var nodeRelative = graph.getNode(link[relativeIdType]);
      link[childType] = nodeChild;
      link[relativeType] = nodeRelative;
      // TODO: Replacing the old link and binding by index may not be safe. The subsequent call to
      // data().enter() may not return the new version of the link, in which case, style and color
      // changes might not take effect.
      console.log("Appending a new link");
      graph.addLink(link);
      // Set the display properties for the new link.
      setDisplayPropertiesForLink(link);
    }
  }

  function start() {
    restart(true);  // init = true
  }

  function restart(init) {
    if (init) {
      svg.append("g").attr("class", "gHalos");
      svg.append("g").attr("class", "gPaths");
      svg.append("g").attr("class", "gTextLink");
      svg.append("g").attr("class", "gSinglePacs");
      svg.append("g").attr("class", "gAggregatePacs");
      svg.append("g").attr("class", "gSingleIndivs");
      svg.append("g").attr("class", "gAggregateIndivs");
      svg.append("g").attr("class", "gSingleCandidates");
      svg.append("g").attr("class", "gAggregateCandidates");
      svg.append("g").attr("class", "gTextNode");
    }

    // Define a special key function with different behavior depending on whether UI elements are
    // being initialized or updated.
    //   - If they're being intialized, simulate the default, by index behavior.
    //   - If they're being updated, use a link or node specific key function.
    function getJoinFunc(keyFunc) {
      return init ? function(d, i) { return i; } : keyFunc;
    }

    function linkKeyFunc(d) { return d.id + "; " + d.amount; }
    function nodeKeyFunc(d) { return d.id + "; " + d.name; }

    function getNodeOpacity(d) {
      // TODO: Consider setting this < 1.0 once the links have been modified to start from the
      // outsides of the PAC circles, rather than from their centers.
      var nonSeedNodeOpacity = 1.0;
      return d.seed ? 1.0 : nonSeedNodeOpacity;
    }

    function getImageForCandidateNode(d) {
      // TODO: Try to find a way to avoid having one .svg file per party.
      var imageToUse = "images/person-" + d.party + ".svg";
      console.log("Selecting image " + imageToUse);
      return imageToUse;
    }

    // Global variables representing UI element selections are defined below.

    halo = svg.select(".gHalos").selectAll(".halo")
        .data(graph.nodes().filter(isExpandableNode), getJoinFunc(nodeKeyFunc));
    halo.exit().remove();
    halo.enter().append("circle")
        .attr("r", 12)
        .attr("class", "halo")
        .attr("opacity", getNodeOpacity)
        .attr("nodeId", function (d) { return d.id; })
        .on("dblclick", dblclick)
        .call(force.drag);

    path = svg.select(".gPaths").selectAll("path")
        .data(graph.links(), getJoinFunc(linkKeyFunc));
    path.exit().remove();
    path.enter().append("path")
        .attr("class",
            function(d) {
              return "link " + linkStyleMapping[d.directorindirect][d.isagainst];
            })
        .attr("marker-end",
            function(d) {
              return "url(#" + isagainstToMarkerColor[d.isagainst] + ")";
            })
        .attr("stroke-width", getWidthForLink);

    linkText = svg.select(".gTextLink").selectAll(".textLink")
        .data(graph.links(), getJoinFunc(linkKeyFunc));
    linkText.exit().remove();
    linkText.enter().append("text")
        .attr("class", "textLink")
        .attr("x", "-8")
        .attr("y", ".31em")
        .text(function(d) { return getLabelForLink(d); });

    singlePac = svg.select(".gSinglePacs").selectAll("image")
        .data(graph.nodes().filter(
            function(d) {
              return d.nodetype == "pac" && !d.aggregate;
            }),
            getJoinFunc(nodeKeyFunc));
    singlePac.exit().remove();
    singlePac.enter().append("image")
        .attr("x", -10)
        .attr("y", -10)
        .attr("width", 20)
        .attr("height", 20)
        .attr("xlink:href", "images/money.svg")
        .attr("opacity", getNodeOpacity)
        .attr("overflow", "visible")
        .attr("nodeId", function (d) { return d.id; })
        .on("dblclick", dblclick)
        .call(force.drag);

    // TODO: Figure out to add a light drop shadow around each circle so that they can overlap
    // and create a better sense of perspective.
    var centerCircleRadius = 6;
    var circleOffset = 14;
    var circleScalingFactor = 0.75;
    aggregatePac = svg.select(".gAggregatePacs").selectAll("g")
        .data(graph.nodes().filter(
            function(d) {
              return d.nodetype == "pac" && d.aggregate;
            }),
            getJoinFunc(nodeKeyFunc));
    aggregatePac.exit().remove();
    var gAggregatePacs = aggregatePac.enter().append("g")
        .attr("opacity", getNodeOpacity)
        .attr("overflow", "visible")
        .attr("nodeId", function (d) { return d.id; })
        .on("dblclick", dblclick)
        .call(force.drag);
    gAggregatePacs.append("image")
        .attr("x", circleScalingFactor * (-centerCircleRadius + circleOffset))
        .attr("y",  circleScalingFactor * -centerCircleRadius)
        .attr("width", centerCircleRadius * circleScalingFactor * 2)
        .attr("height", centerCircleRadius * circleScalingFactor * 2)
        .attr("xlink:href", "images/money.svg");
    gAggregatePacs.append("image")
        .attr("x", circleScalingFactor * (-centerCircleRadius - circleOffset))
        .attr("y", circleScalingFactor * -centerCircleRadius)
        .attr("width", centerCircleRadius * circleScalingFactor * 2)
        .attr("height", centerCircleRadius * circleScalingFactor * 2)
        .attr("xlink:href", "images/money.svg");
    gAggregatePacs.append("image")
        .attr("x", -centerCircleRadius)
        .attr("y", -centerCircleRadius)
        .attr("width", centerCircleRadius * 2)
        .attr("height", centerCircleRadius * 2)
        .attr("xlink:href", "images/money.svg");

    singleIndiv = svg.select(".gSingleIndivs").selectAll("image")
        .data(graph.nodes().filter(
            function(d) {
              return d.nodetype == "indiv" && !d.aggregate;
            }),
        getJoinFunc(nodeKeyFunc));
    singleIndiv.exit().remove();
    singleIndiv.enter().append("image")
        .attr("x", "-4")
        .attr("y", "-10")
        .attr("width", 8)
        .attr("height", 20)
        .attr("xlink:href", "images/indiv.svg")
        .attr("opacity", getNodeOpacity)
        .attr("nodeId", function (d) { return d.id; })
        .on("dblclick", dblclick)
        .call(force.drag);
    
    // TODO: Figure out to add a light drop shadow around each person so that they can overlap
    // and create a better sense of perspective.
    var centerPersonWidth = 6;
    var centerPersonHeight = 16;
    var personOffset = 8;
    var personScalingFactor = 0.75;
    aggregateIndiv = svg.select(".gAggregateIndivs").selectAll("g")
        .data(graph.nodes().filter(
            function(d) {
              return d.nodetype == "indiv" && d.aggregate;
            }),
            getJoinFunc(nodeKeyFunc));
    aggregateIndiv.exit().remove();
    var gAggregateIndivs = aggregateIndiv.enter().append("g")
        .attr("opacity", getNodeOpacity)
        .attr("nodeId", function (d) { return d.id; })
        .on("dblclick", dblclick)
        .call(force.drag);
    gAggregateIndivs.append("image")
        .attr("x", personScalingFactor * (centerPersonWidth / -2 + personOffset))
        .attr("y",  personScalingFactor * centerPersonHeight / -2)
        .attr("width", centerPersonWidth * personScalingFactor)
        .attr("height", centerPersonHeight * personScalingFactor)
        .attr("xlink:href", "images/indiv.svg");
    gAggregateIndivs.append("image")
        .attr("x", personScalingFactor * (centerPersonWidth / -2 - personOffset))
        .attr("y", personScalingFactor * centerPersonHeight / -2)
        .attr("width", centerPersonWidth * personScalingFactor)
        .attr("height", centerPersonHeight * personScalingFactor)
        .attr("xlink:href", "images/indiv.svg");
    gAggregateIndivs.append("image")
        .attr("x", centerPersonWidth / -2)
        .attr("y", centerPersonHeight / -2)
        .attr("width", centerPersonWidth)
        .attr("height", centerPersonHeight)
        .attr("xlink:href", "images/indiv.svg");

    singleCandidate = svg.select(".gSingleCandidates").selectAll("image")
        .data(graph.nodes().filter(
            function(d) {
              return d.nodetype == "candidate" && !d.aggregate;
            }),
            getJoinFunc(nodeKeyFunc));
    singleCandidate.exit().remove();
    singleCandidate.enter().append("image")
        .attr("x", "-4")
        .attr("y", "-10")
        .attr("width", 8)
        .attr("height", 20)
        .attr("xlink:href", getImageForCandidateNode)
        .attr("opacity", getNodeOpacity)
        .attr("nodeId", function (d) { return d.id; })
        .on("dblclick", dblclick)
        .call(force.drag);

    // TODO: Figure out to add a light drop shadow around each person so that they can overlap
    // and create a better sense of perspective.
    var centerPersonWidth = 6;
    var centerPersonHeight = 16;
    var personOffset = 8;
    var personScalingFactor = 0.75;
    aggregateCandidate = svg.select(".gAggregateCandidates").selectAll("g")
        .data(graph.nodes().filter(
            function(d) {
              return d.nodetype == "candidate" && d.aggregate;
            }),
            getJoinFunc(nodeKeyFunc));
    aggregateCandidate.exit().remove();
    var gAggregateCandidates = aggregateCandidate.enter().append("g")
        .attr("opacity", getNodeOpacity)
        .attr("nodeId", function (d) { return d.id; })
        .on("dblclick", dblclick)
        .call(force.drag);
    gAggregateCandidates.append("image")
        .attr("x", personScalingFactor * (centerPersonWidth / -2 + personOffset))
        .attr("y",  personScalingFactor * centerPersonHeight / -2)
        .attr("width", centerPersonWidth * personScalingFactor)
        .attr("height", centerPersonHeight * personScalingFactor)
        .attr("xlink:href", getImageForCandidateNode);
    gAggregateCandidates.append("image")
        .attr("x", personScalingFactor * (centerPersonWidth / -2 - personOffset))
        .attr("y", personScalingFactor * centerPersonHeight / -2)
        .attr("width", centerPersonWidth * personScalingFactor)
        .attr("height", centerPersonHeight * personScalingFactor)
        .attr("xlink:href", getImageForCandidateNode);
    gAggregateCandidates.append("image")
        .attr("x", centerPersonWidth / -2)
        .attr("y", centerPersonHeight / -2)
        .attr("width", centerPersonWidth)
        .attr("height", centerPersonHeight)
        .attr("xlink:href", getImageForCandidateNode);

    nodeText = svg.select(".gTextNode").selectAll(".textNode")
        .data(graph.nodes(), getJoinFunc(nodeKeyFunc));
    nodeText.exit().remove();
    nodeText.enter().append("text")
        .attr("class", "textNode")
        .attr("opacity", getNodeOpacity)
        .attr("x", "8")
        .attr("y", ".31em")
        .text(function(d) { return d.name; });

    force.start();
  }
}

</script>
</body>

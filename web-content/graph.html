<!DOCTYPE html>
<meta charset="utf-8">
<style>

#black {
  fill: black
}
#red {
  fill: red
}

.link {
  fill: none;
  stroke-width: 1.5px;
}
.link.plain.gray {
  stroke: #666;
}
/* This will probably never be used in practice. */
.link.plain.red {
  stroke: red;
}
.link.dashed {
  stroke-dasharray: 0,2 1;
}
.link.dashed.gray {
  stroke: #666;
}
.link.dashed.red {
  stroke: red;
}

.halo {
  stroke: #ccc;
  stroke-width: 4px;
  fill: none
}
.circle {
  stroke: #333;
  stroke-width: 1.5px;
}
.circle.gray {
  fill: #bbb;
}
.circle.white {
  fill: white;
}
.circle.red {
  fill: red;
}
.circle.blue {
  fill: blue;
}
.circle.gold {
  fill: yellow;  /* TODO: gold */
}
.circle.purple {
  fill: purple;
}

text {
  font: 10px sans-serif;
  pointer-events: none;
  text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, -1px 0 0 #fff;
}

</style>
<head>
  <!-- TODO: What Content-Type should we set here? -->
  <link rel="shortcut icon" type="image/jpg" href="marionette.jpg" />
  <title>"See the Strings"</title>
</head>

<body>

<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="url-bundle.js"></script>
<script src="underscore-bundle.js"></script>
<script src="db-shim.js"></script>

<script>

var linkStyleMapping = {
  "D": {
    "true": "plain red",
    "false": "plain gray",
  },
  "I": {
    "true": "dashed red",
    "false": "dashed gray",
  },
};

var isagainstToMarkerColor = {
  "true": "red",
  "false": "black"
};

function getStyleForParty(party) {
  switch (party) {
  case "R": return "red";
  case "D": return "blue";
  case "L": return "gold";
  case "3": return "purple";
  default: return "white" 
  }
}

function getLabelForLink(link) {
  // TODO: Consider displaying a refund by reversing the direction of the arrow, rather than by
  // showing a negative amount.
  //
  // Chrome and Firefox for Android don't render dollar signs generated by Number.toLocaleString()
  // correctly, so rather than pass in options { style: 'currency', currency: 'USD' }, we manually
  // add the dollar sign (and a minus sign if applicable).
  var absAmount = Math.abs(link.amount);
  var formattedAmount = (link.amount >= 0 ? "$" : "-$")
      + Number(absAmount).toLocaleString('en-US');
  return formattedAmount + (link.isRefund ? " (refund)" : "");
}

// TODO: It seems like this file shouldn't need to know about candidates or PACs.
//
// Can we pull this logic up into the form?
function getAggregateTypeForSeedType(seedType) {
  if (seedType == "Candidate" || seedType == "Race") {
    return "source";
  } else if (seedType == "PAC") {
    return "target";
  } else {
    console.log("Error: unknown seedType " + seedType);
    return null;
  }
}
function setDisplayPropertiesForCandidateNode(node, link) {
  if (node.name == null) {
    if (link.targetname != null) {
      node.name = link.targetname;
    } else if (link.subLinks != null) {
      node.name = link.count + " candidates. Double click...";
    }
  }
  if (node.party == null || node.party == "U") {
    if (link.party != null) {
      node.party = link.party;
      console.log("Getting party " + node.party + " from link");
    } else {
      console.log("Party unknown");
      node.party = "U";  // unknown party
    }
  }
}
function setDisplayPropertiesForPacNode(node, link) {
  if (node.name == null) {
    if (link.sourcename != null) {
      node.name = link.sourcename;
    } else if (link.subLinks != null) {
      node.name = link.count + " contributors. Double click...";
    }
  }
}
function setDisplayPropertiesForNode(node, link) {
  if (node.id == link.sourceid) {
    setDisplayPropertiesForPacNode(node, link);
  } else if (node.id == link.targetid) {
    setDisplayPropertiesForCandidateNode(node, link);
  } else {
    console.log("Error: node and link passed in are not related to each other");
  }
}

d3.json("/data" + window.location.search, handleResponse);

function handleResponse(err, rows) {
  // TODO: Check for errors.

  var queryParams = Url.parse(window.location.search, true).query;
  var seedType = queryParams["seedType"];
  console.log("Got seedType: " + seedType);

  var aggregateType = getAggregateTypeForSeedType(seedType);
  var links = processRows(rows, aggregateType);

  buildGraph(links);
}

function buildGraph(links) {
  var nodes = {};
  // Compute the distinct nodes from the links.
  links.forEach(
      function(link) {
        link.source = nodes[link.sourceid] ||
            (nodes[link.sourceid] = {
              name: link.sourcename,
              id: link.sourceid,
            });
        link.target = nodes[link.targetid] ||
            (nodes[link.targetid] = {
              name: link.targetname,
              id: link.targetid,
            });
        // Set the display properties for both nodes based on the properties of the link.
        setDisplayPropertiesForNode(link.source, link);
        setDisplayPropertiesForNode(link.target, link);
        if (link.subLinks != null) {
          // Add a reference to the aggregate link to the aggregate node so that we can find the
          // sub links when the user wants to expand it.
          link[link.childType].aggregateLink = link;
        }
      });
  var width = 1600,
      height = 1000;

  var svg = d3.select("body").append("svg")
      .attr("width", width)
      .attr("height", height);

  svg.append("g").selectAll("image")
      .data([0])
    .enter().append("image")
      .attr("x", 0)
      .attr("y", 0)
      .attr("width", 450)
      .attr("height", 300)
      .attr("xlink:href","legend.svg")

  var force = d3.layout.force()
      .nodes(d3.values(nodes))
      .links(links)
      .size([width, height])
      .linkDistance(200)
      .charge(-300)
      .friction(.75)
      .on("tick", tick);

  // Per-color markers, as they don't inherit styles.
  svg.append("defs").selectAll("marker")
      .data(["black", "red"])
    .enter().append("marker")
      .attr("id", function(d) { return d; })
      .attr("viewBox", "0 -5 10 10")
      .attr("refX", 15)
      .attr("refY", -1.5)
      .attr("markerWidth", 6)
      .attr("markerHeight", 6)
      .attr("orient", "auto")
    .append("path")
      .attr("d", "M0,-5L10,0L0,5");

  start();

  // TODO: Consider going back to elliptical arc path segments to doubly-encode directionality.
  function tick() {
    path.attr("d", linkLine);
    circle.attr("transform", transformNodes);
    halo.attr("transform", transformNodes);
    nodeText.attr("transform", transformNodes);
    linkText.attr("transform", transformLinkText);
  }

  function linkLine(d) {
    var dx = d.target.x - d.source.x,
        dy = d.target.y - d.source.y;
    return "M" + d.source.x + "," + d.source.y + "L" + d.target.x + "," + d.target.y;
  }

  function transformNodes(d) {
    return "translate(" + d.x + "," + d.y + ")";
  }

  function transformLinkText(d) {
    return "translate(" + (d.source.x + d.target.x) / 2 + "," + (d.source.y + d.target.y) / 2 + ")";
  }

  // action to take on mouse double click
  function dblclick() {
    var nodeId = d3.select(this).attr("nodeId");
    var clickedNode = nodes[nodeId];
    var n = force.nodes().indexOf(clickedNode);
    if (clickedNode == null || n == -1) {
      console.log("Clicked node can't be found!");
      return;
    }
    if (!clickedNode.aggregateLink) {
      console.log("Clicked node is not an aggregate node")
      return;
    }
    var aggregateLink = clickedNode.aggregateLink;
    console.log("Removing existing link");
    force.links().splice(force.links().indexOf(clickedNode.aggregateLink), 1);
    console.log("Removing existing " + childNameType + " node");
    force.nodes().splice(n, 1);

    var subLinks = aggregateLink.subLinks;
    var childType = aggregateLink.childType,
        childIdType = aggregateLink.childIdType,
        childNameType = aggregateLink.childNameType,
        relativeType = aggregateLink.relativeType,
        relativeIdType = aggregateLink.relativeIdType,
        relativeNameType = aggregateLink.relativeNameType;

    console.log("Clicked node has id " + clickedNode.id + " and name " + clickedNode.name);
    console.log("Link for clicked node has " + subLinks.length + " sub links");
    for (i = 0; i < subLinks.length; ++i) {
      var link = subLinks[i];
      console.log("Sub link " + i + " has name " + link[childNameType] + " and amount "
          + link.amount);
      // TODO: Should we get fully populated value from force.nodes()?
      var nodeChild = nodes[link[childIdType]];
      if (nodeChild == null || nodeChild.name != link[childNameType]) {
        nodeChild = nodes[link[childIdType]] = {
          name: link[childNameType],  // This will be null if the child is another aggregate.
          id: link[childIdType]
        };
        force.nodes().push(nodeChild);
        // Set the display properties for the new node based on the properties of the link.
        setDisplayPropertiesForNode(nodeChild, link);
        if (link.subLinks != null) {
          // Add a reference to the aggregate link to the aggregate node so that we can find the
          // sub links when the user wants to expand it.
          nodeChild.aggregateLink = link;
        }
      }
      // The relative of the clicked node should already exist in the graph, because the aggregate
      // was already linking to it.
      var nodeRelative = nodes[link[relativeIdType]];
      link[childType] = nodeChild;
      link[relativeType] = nodeRelative;
      // TODO: Replacing the old link and binding by index may not be safe. The subsequent call to
      // data().enter() may not return the new version of the link, in which case, style and color
      // changes might not take effect.
      console.log("Appending a new link");
      force.links().push(link);
    }

    restart();
  }

  function start() {
    restart(true);  // init = true
  }

  function restart(init) {
    if (init) {
      svg.append("g").attr("class", "gPaths");
      svg.append("g").attr("class", "gTextLink");
      svg.append("g").attr("class", "gCircles");
      svg.append("g").attr("class", "gHalos");
      svg.append("g").attr("class", "gTextNode");
    }

    // Define a special key function with different behavior depending on whether UI elements are
    // being initialized or updated.
    //   - If they're being intialized, simulate the default, by index behavior.
    //   - If they're being updated, use a link or node specific key function.
    function getJoinFunc(keyFunc) {
      return init ? function(d, i) { return i; } : keyFunc;
    }

    function linkKeyFunc(d) { return d.id + "; " + d.amount; }
    function nodeKeyFunc(d) { return d.id + "; " + d.name; }

    function isAggregateNode(d) { return d.aggregateLink != null; }

    // Global variables representing UI element selections are defined below.

    path = svg.select(".gPaths").selectAll("path")
        .data(force.links(), getJoinFunc(linkKeyFunc));
    path.exit().remove();
    path.enter().append("path")
        .attr("class",
            function(d) {
              return "link " + linkStyleMapping[d.directorindirect][d.isagainst];
            })
        .attr("marker-end",
            function(d) {
              return "url(#" + isagainstToMarkerColor[d.isagainst] + ")";
            });

    linkText = svg.select(".gTextLink").selectAll(".textLink")
        .data(force.links(), getJoinFunc(linkKeyFunc));
    linkText.exit().remove();
    linkText.enter().append("text")
        .attr("class", "textLink")
        .attr("x", "-8")
        .attr("y", ".31em")
        .text(function(d) { return getLabelForLink(d); });

    circle = svg.select(".gCircles").selectAll("circle")
        .data(force.nodes(), getJoinFunc(nodeKeyFunc));
    circle.exit().remove();
    circle.enter().append("circle")
        .attr("r", 6)
        .attr("nodeId", function (d) { return d.id; })
        .attr("class",
            function (d) {
              return "circle " + (d.party != null ? getStyleForParty(d.party) : "gray");
            })
        .on("dblclick", dblclick)
        .call(force.drag);

    halo = svg.select(".gHalos").selectAll(".halo")
        .data(force.nodes().filter(isAggregateNode), getJoinFunc(nodeKeyFunc));
    halo.exit().remove();
    halo.enter().append("circle")
        .attr("r", 11)
        .attr("nodeId", function (d) { return d.id; })
        .attr("class", "halo")
        .on("dblclick", dblclick)
        .call(force.drag);

    nodeText = svg.select(".gTextNode").selectAll(".textNode")
        .data(force.nodes(), getJoinFunc(nodeKeyFunc));
    nodeText.exit().remove();
    nodeText.enter().append("text")
        .attr("class", "textNode")
        .attr("x", "8")
        .attr("y", ".31em")
        .text(function(d) { return d.name; });

    force.start();
  }
}

</script>
</body>
